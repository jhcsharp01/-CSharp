using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace ConsoleApp1.Day08
{
    //인터페이스(Interface)
    //상호 간의 약속
    //중간 다리 역할

    //일반 클래스, 추상 클래스와의 비교
    //일반 클래스의 경우 기능에 대한 완성이 되어있는 설계도
    //추상 클래스(abstract)의 경우 부분적으로 기능이 완성되어있는 미완성 설계도
    //인터페이스의 경우 틀만 설계되어 있는 설계도 

    //이유?
    //전체적으로 틀을 짜주는 것으로, 개발 기간에 대한 단축 효과를 볼 수 있음.
    //전체적으로 틀이 짜여잇기 때문에, 여러 명의 개발자가 같은 양식에서 내용을 구현합니다.
    //이는 코드의 표준화, 정형화에 큰 도움이 될 것입니다.
    //틀만 지키면 나머지는 자유롭게 작업해도 되기 때문에 독립적인 프로그래밍 설계가 가능합니다.
    // >> 클래스의 선언과 클래스의 구현이 분리되어있기 때문
    //일반적인 상속과 다르게 인터페이스를 통한 상속은 서로 관계 없는 클래스 끼리의 연결고리를 만들어 줄 수
    //있습니다.

    //특징)
    //1. 인터페이스를 상속받는 클래스에게 오버라이딩을 강제합니다.
    //2. 모든 것이 public으로 선언됩니다.
    //3. 인스턴스를 만들 수 없습니다. 대신 인터페이스를 상속받는 클래스의
    //인스턴스를 만드는 것은 가능합니다.
    //4. 인터페이스는 메소드, 이벤트, 인덱서, 프로퍼티를 가질 수 있습니다.
    //5. 구현부를 가질 수 없습니다.  ex) method();


    //인터페이스의 설계 목적 중 하나인 다중 상속의 문제
    //C#에서 다중 상속은 기본적으로 제한되어 있습니다.


    class A //: B,C //불가능
    {
        public int value;
        public void Action01() { }
    }
    class B : A
    {
        public int value2;
    }
    class C : A
    {
        public int value2;
    }
    class D// : B,C
    {

    }
    //그림처럼 상속을 하는 과정에서 다중 상속을 받게 될 경우 누구의 값인지 판단이 애매한 상황이 발생합니다.(모호성)
    //저런 형태의 상속을 보통 Diamond 상속이라 부릅니다.

    //인터페이스에서는 다이아몬드 상속 문제가 발생하지 않느냐?
    //문제가 생기지 않습니다.
    //구현되지 않은 이름만 전달하기 때문에 이름 받고 기능만 구현하면 큰 문제 없다.

    internal class Class40
    {
    }
}
